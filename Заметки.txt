Поле - двухмерный массив ячеек (Cell)
Каждая ячейка хранит в себе координаты, переменную занятости и состояние взрыва. Переменная занятости ссылается на объект, являющимся препятствием. Стена неразрушаемая, ящик разрушаемый, бомба разрушаемая.
Базовое препятствие имеет свои координаты, разрушаемость и название. Стена и ящик - это препятствия с разными названиями.

Генерация ящиков завязана на стенах внутри игрового поля. Такие "внутренние" стены имеют координаты (2,2), (4,2), (4,2), (4,4) и т.д. Вокруг каждой внутренней стены можно описать область игровых клеток. В зависимости от расположения стены такая область будет иметь 8, 5 или 3 клетки. В целях упрощения алгоритма генерации размеры игрового поля должны быть нечётными, например 11 на 9. Это условие гарантирует, что область игровых клеток вокруг внутренних стен будет 8 клеток(квадрат 3*3 без центра). 
Поле 11 на 9 будет иметь 12 внутренних стен, на каждую стену генерируется 2 ящика. Стена (2,2) пропускается из генерации ради гарантированного свободного пространства рядом с игроком. В каждой области пытается расставиться 2 ящика: генерируется случайное смещение для каждой координаты в диапазоне -1...+1, проверяется адрес со смещением. Если есть препятствие, генерируется новое смещение и проверяется заново. Количество проверок для одной области ограничено, не поставилось - и бог с ним. Если препятствия нет, ящик ставится. И так для каждой области. Области пересекаются друг с другом.
Грибочек ставится после расстановки ящиков. 

Базовая сущность имеет координаты, метод проверки ячеек на возможность перехода, метод перехода в другую ячейку (логика проверки и перехода на сущности, а не на самом поле). 
Метод проверки ячейки получает на вход координаты проверяемой ячейки, проверяет корректность координат, проверяет наличие препятствия. Возвращает true, если переход возможен, false - если нет. Контроль соседства на вызывающем коде.
Метод перехода получает на вход координаты ячейки и ставит их как местоположение сущности.
Игрок(hero) наследуется от сущности, имеет метод установки бомбы.
Грибочек наследуется от сущности, шароёбится между ящиками и ждёт своей участи.
Бомба наследуется от препятствия. Имеет метод взрыва.
Бомба имеет координаты и количество шагов (времени) до взрыва. Когда количество шагов доходит до нуля, бомба разрушается и создаёт несколько клеток со взрывами. Взрывы устанавливаются на месте бомбы и в прямой видимости от неё на 2 блока в каждую сторону (+x, -x, +y, -y), не считая эпицентра. Каждое направление генерации взрывов - ударная волна. 
Если волна упирается в препятствие, проверяется разрушаемость: если препятствие разрушаемо, то оно разрушается и его координаты становятся последним взрывом в волне, если нет - волна останавливается на клетке до препятствия. 
Взрыв не препятствие, взрыв - условие смерти. Если взрыв устанавливается в ячейку с сущностью, сущность погибает.
Взрыв - это отдельное состояние ячейки.
Взрывная волна игнорирует другую взрывную волну.
Если грибочек и герой "встретятся" в одной ячейке (ссылаются на одну ячейку в качестве своего местоположения), герой погибает.
Если встретятся грибочек и грибочек, то ничего не произойдёт. Но грибочки не любят встречаться на одной ячейке и попытаются этого избежать.
У игрока есть три жизни на старте. Каждая смерть однимает одну жизнь. При числе жизней, равном нулю, игра оканчивается. При уменьшении жизней уровень перезапускается заново.
В игре три уровня, отличаются количеством грибочков(2, 3, 4) и количеством разрушаемых препятствий(?). Условием прохождения уровня считается смерть всех грибочков. При прохождении уровня игрок переходит на следующий. При прохождении всех трёх уровней игра считается пройденной. После завершения игры игроку показывается результат и таблица лидеров, результат сохраняется в localStorage.

Идея для генерации ящиков: по 3 ящика на нечётный столбец, 2 на чётный. Распихивать в столбец положенное количество ящиков случайным образом до тех пор, пока не распихнётся.

Отображение игровых элементов на поле:
- Каждый игровой элемент на поле должен иметь node-двойника
- Изменение элемента добавляет node в список на перерисовку
- Соответствие элемента и его node-двойника ... хз как, новый класс interface
- Каждое изменение элемента должно изменять список изменённых node
- Каждый тик все node из списка изменённых должны получить новое состяние из "своего" элемента

Пересчёт игрового поля:
- какой-нибудь setInterval вызывает главный метод пересчёта game.tick()
- tick вызывает методы:
-- ход игрока hero.move()
-- ход грибочков mush.move()
-- обновление состояния игрока hero.update()
-- пересчёт бомбы bomb.update()
-- обновление состояния грибочков mush.update()
-- пересчёт ящиков box.update()(сами пересчитаются при взрыве?)
